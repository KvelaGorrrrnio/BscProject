\chapter*{Background}
\addcontentsline{toc}{chapter}{Background}%

In this chapter, we will briefly discuss the background of the implementation project. We will dive into the definitions, and some of the theory, presented in \cite{REV}. % lidt mere?

% TODO: overordnet om flowcharts og reversible flowcharts
\section*{Reversible Flowcharts}
\addcontentsline{toc}{section}{Reversible Flowcharts}%
Flowcharts are a natural way to model imperative programs. Similarly, \textit{reversible} imperative programs can be naturally modeled by reversible flowcharts. The two models are similar --- however, to actually guarantee reversibility in reversible flowcharts, we may define some additional attributes. More specifically, we may want any join point between two edges in a flowchart to be acknowledged through an assertion which can determine the origin of the control flow. The definition as seen in~\cite{REV} says that \\

\say{A \textit{reversible flowchart $F$} is a finite directed graph with three types of nodes, each of which represents an \textit{atomic operation}} \\

\noindent T. Yokotama et al.\ move on to describe the three atomic operations:\\
\begin{description}
  \item[(a)] the \textit{step} operation performs some injective (i.e.\ reversible) operation and passes the control flow to the outgoing edge,
  \item[(b)] the \textit{test} passes the control flow to one of two outgoing edges depending on a predicate $e$, and
  \item[(c)] the \textit{assertion} joins two edges and passes the control flow depending on a predicate $e$.
\end{description}~\\
\noindent The atomic operations can be seen in Figure~\ref{fig:atop}. Having these as elementary building blocks of our reversible flowcharts, it is trivial to invert a program; simply invert each edge and, naturally, any step operation in the flowchart. This, in turn, means that the inversion of a test is an assertion and vice versa. The inversion of each atomic operation can be seen in Figure~\ref{fig:atopinv}.

\begin{figure}[H]
  \centering
  \begin{subfigure}[t]{0.3\textwidth}
    \centering
    \scalebox{0.8}{%
      \begin{tikzpicture}[auto, thick, node distance=2cm, >=triangle 45]
        \node (a) [stmt] {$a$};
        \node [output] (up)    [above of=a, node distance=1.1cm]{};
        \node [input]  (end)   [right of=a, node distance=1.5cm]{};
        \node [output] (start) [left  of=a, node distance=1.5cm]{};
        \node [output] (down)  [below of=a, node distance=1.1cm]{};

        \path[->] (start) edge node {} (a);
        \path[->] (a) edge node {} (end) ;

        \path[draw=none] (up) node {} (a);
        \path[draw=none] (down) node {} (a);
      \end{tikzpicture}
    }
    \caption{Step}
  \end{subfigure}
  \begin{subfigure}[t]{0.3\textwidth}
    \centering
    \scalebox{0.8}{%
      \begin{tikzpicture}[auto, thick, node distance=2cm, >=triangle 45]
        \node (a) [test] {$e$};
        \node [input]  (start) [left of=a, node distance=1.5cm]{};
        \node [output]  (up)   [above of=a, node distance=1.2cm]{};
        \node [output]  (ur)   [right of=up, node distance=1.2cm]{};
        \node [output] (down)  [below of=a, node distance=1.2cm]{};
        \node [output] (dr)    [right of=down, node distance=1.2cm]{};

        \path[->] (start) edge node {} (a);
        \path[-] (a) edge node {$t$} (up);
        \path[->] (up) edge node {} (ur);
        \path[-] (a) edge node {$f$} (down);
        \path[->] (down) edge node {} (dr);
      \end{tikzpicture}
    }
    \caption{Test}
  \end{subfigure}
  \begin{subfigure}[t]{0.3\textwidth}
    \centering
    \scalebox{0.8}{%
      \begin{tikzpicture}[auto, thick, node distance=2cm, >=triangle 45]
        \node [assert] (a)    {$e$};
        \node [input]  (up)   [below of=a, node distance=1.2cm]{};
        \node [input]  (dr)   [left of=up, node distance=1.2cm]{};
        \node [input]  (down) [above of=a, node distance=1.2cm]{};
        \node [input]  (ur)   [left of=down, node distance=1.2cm]{};
        \node [output] (end)  [right of=a, node distance=1.5cm]{};

        \path[-] (dr) edge node {} (up);
        \path[->] (up) edge node {$f$} (a);
        \path[-] (ur) edge node {} (down);
        \path[->] (down) edge node {$t$} (a);
        \path[->] (a) edge node {} (end);
      \end{tikzpicture}
    }
    \caption{Assertion}
  \end{subfigure}
  \caption{The three atomic operations of reversible flowcharts}\label{fig:atop}
\end{figure}

\begin{figure}[H]
  \centering
  \begin{subfigure}[t]{0.3\textwidth}
    \centering
    \scalebox{0.8}{%
      \begin{tikzpicture}[auto, thick, node distance=2cm, >=triangle 45]
        \node (a) [stmt] {$a^{-1}$};
        \node [output] (up)    [above of=a, node distance=1.3cm]{};
        \node [input]  (end)   [right of=a, node distance=1.5cm]{};
        \node [output] (start) [left  of=a, node distance=1.5cm]{};
        \node [output] (down)  [below of=a, node distance=1.3cm]{};

        \path[->] (a) edge node {} (start);
        \path[->] (end) edge node {} (a) ;

        \path[draw=none] (up) node {} (a);
        \path[draw=none] (down) node {} (a);
      \end{tikzpicture}
    }
    \caption{Step}
  \end{subfigure}
  \begin{subfigure}[t]{0.3\textwidth}
    \centering
    \scalebox{0.8}{%
      \begin{tikzpicture}[auto, thick, node distance=2cm, >=triangle 45]
        \node [assert] (a)    {$e$};
        \node [input]  (up)   [below of=a, node distance=1.2cm]{};
        \node [input]  (dr)   [right of=up, node distance=1.2cm]{};
        \node [input]  (down) [above of=a, node distance=1.2cm]{};
        \node [input]  (ur)   [right of=down, node distance=1.2cm]{};
        \node [output] (end)  [left of=a, node distance=1.5cm]{};

        \path[-] (dr) edge node {} (up);
        \path[->] (up) edge node {$f$} (a);
        \path[-] (ur) edge node {} (down);
        \path[->] (down) edge node {$t$} (a);
        \path[->] (a) edge node {} (end);
      \end{tikzpicture}
    }
    \caption{Assertion}
  \end{subfigure}
  \begin{subfigure}[t]{0.3\textwidth}
    \centering
    \scalebox{0.8}{%
      \begin{tikzpicture}[auto, thick, node distance=2cm, >=triangle 45]
        \node (a) [test] {$e$};
        \node [input]  (start) [right of=a, node distance=1.5cm]{};
        \node [output]  (up)   [above of=a, node distance=1.2cm]{};
        \node [output]  (ur)   [left of=up, node distance=1.2cm]{};
        \node [output] (down)  [below of=a, node distance=1.2cm]{};
        \node [output] (dr)    [left of=down, node distance=1.2cm]{};

        \path[->] (start) edge node {} (a);
        \path[-] (a) edge node {$t$} (up);
        \path[->] (up) edge node {} (ur);
        \path[-] (a) edge node {$f$} (down);
        \path[->] (down) edge node {} (dr);
      \end{tikzpicture}
    }
    \caption{Test}
  \end{subfigure}
  \caption{Inversion of the three atomic operations of reversible flowcharts}\label{fig:atopinv}
\end{figure}

% figurer af de forskellige byggeklodser her tak

\noindent This is the general idea of reversible flowcharts, and two incarnations of this model are RL and SRL.\



% går så videre til det mere specifikke med RL og SRL
% og snakker om den formelle syntaks
\section*{RL and SRL}
\addcontentsline{toc}{section}{RL and SRL}%
\noindent Reversible Language and Structured Reversible Language --- RL and SRL for short, repectively --- are two reversible flowchart languages proposed in~\cite{REV}. RL is an assembly-like language with unstructured jumps, while SRL, as the name indicates, is a similar language but with control structures and no jumps. The two languages share a common subset of features --- namely their statements and expressiions. The grammar of the two languages along with the common structures are given in~\cite{REV} and can be seen in Figure~\ref{fig:rl_srl_grammar_and_structure}.\\

\noindent As we see, RL, described in Figure~\ref{fig:rlspec}, consists of one or more (RL-)blocks, where each block is (uniquely) defined by a label and has a come-from assertion, zero or more step operations and an unstructured jump to any block in the program. Note that a well-formed RL program must contain exactly one entry and one exit.

SRL is more linear; as we see in Figure~\ref{fig:srlspec}, a program consists of exactly one (SRL-)block, where a block may either be an atomic step operation, a control structure --- that is, an \texttt{if}- or a \texttt{do-until} structure --- or recursively a sequence of two blocks. Sequences of blocks are executed in order, and thus, an SRL program looks a lot like a program written in common programming languages such as Python or C, to name a few. Note that a block in RL is different from a block in SRL.\\

\noindent As mentioned, the two languages share expressions and step operations along with the basic value types. A brief overview:\\

\begin{description}
  \item[Values and types]~\
  \begin{itemize}
    \item A variable can either be mapped to an integer or to a list of integers.
    \item We only have integer literals; to obtain a certain list of integers, one has to bind each of the wanted values to a variable and push it to a list.
    \item Boolean values are represented by integers. If a variable maps to a non-zero integer value it will evaluate to true, and false otherwise.
  \end{itemize}
  \item [Step operations]~\
  \begin{itemize}
    \item To modify a variable, we have the variable update. The variable update only supports reversible operators, namely addition and subtraction. Indexing is supported. One rule is that the identifier being updated must not occur in the right-hand expression since such an update is irreversible.
    \item You can push the value of a variable onto a list with the \texttt{push} step operation. The variable being pushed must be zero-cleared afterwards.
    \item You can pop the top value from a list into a variable with the \texttt{pop} step operation. The variable must be zero-cleared beforehand.
    \item The \texttt{skip} step operation does nothing.
  \end{itemize}
  \item [Expressions]~\
  \begin{itemize}
    \item We can have any arbitrary binary operator between two expressions, recursively.
    \item An expression terminates with an integer literal or a variable lookup.
    \item The \texttt{top} expression is unary and returns the top of the operand.
    \item The \texttt{empty} predicate is unary and returns true if the operand is empty and false otherwise.
  \end{itemize}
\end{description}

% figur der viser grammatikken her tak
\begin{figure}[]

  \begin{subfigure}{\textwidth}
    \center
    $$\begin{matrix*}[l]
      {p} & ::= & {b} & \quad & {b} & ::= & a             & | & \texttt{ if }e\texttt{ then }b\texttt{ else }b\texttt{ fi }e\\
                 &     &           &        &            &  |  & b\ b & | & \texttt{ from }e\texttt{ do }b\texttt{ loop }b\texttt{ until }e\\
    \end{matrix*}$$
    \caption{Structured reversible language \textit{SRL}.}
    \label{fig:srlspec}
  \end{subfigure}

  \begin{subfigure}{\textwidth}
    \center
    $$\begin{matrix*}[l]
      {q} & ::= & {d}^+                                      & & {k} & ::= & \texttt{from }l & & {j} & ::= & \texttt{goto }l\\
      {d} & ::= & {l}:\ {k}\ {a}^*\ {j} &       &            &  |  & \texttt{fi }e\texttt{ from }l\texttt{ else }l &
        & & | & \texttt{if }e\texttt{ goto }l\texttt{ else }l\\
    \end{matrix*}$$
    \caption{Unstructured reversible language \textit{RL}.}
    \label{fig:rlspec}
  \end{subfigure}

  \begin{subfigure}{\textwidth}
    \center
    $$\begin{matrix*}[l]
      {a} & ::= & {x}\oplus= e & \quad\quad\quad &  e & ::= & {c} \ | \ {x} \ | \ {x}[ e] \ | \  e\otimes e \ | \ \texttt{top }{x} \ | \ \texttt{empty }{x}\\
                 &  |  & {x}[ e]\oplus= e &     & {c} & ::= & 0\ | \ 1\ |\ \cdots\ |\ 4294967295\\
                 &  |  & \texttt{push }{x}\ {x}      &     & \otimes    & ::= & \oplus \ | \ * \ | \ / \ | \ \cdots\\
                 &  |  & \texttt{pop  }{x}\ {x}      &     & \oplus     & ::= & +  \ | \  -  \ | \  \textasciicircum\\
                 &  |  & \texttt{skip}\\
    \end{matrix*}$$
    \caption{Reversible step operations and expressions.}
  \end{subfigure}

  \begin{subfigure}{\textwidth}
    \center
    $$\begin{matrix*}[l]
      \mathtt{SRL}:     & {p}\in\mathtt{SRL}  & & {b}\in\mathtt{Blk}\\
      \mathtt{RL}:      & {q}\in\mathtt{RL}   & & {d}\in\mathtt{RLBlk} & & {j}\in\mathtt{Jump}  & & {k}\in\mathtt{From} & & {l}\in\mathtt{Label}\\
      \mathtt{SRL, RL}: & {a}\in\mathtt{Step} & &  e\in\mathtt{Exp}   & & {c}\in\mathtt{Const} & & {x}\in\mathtt{Var}  & & \oplus,\otimes\in\mathtt{Op}\\
    \end{matrix*}$$
    \caption{Syntax domains of \textit{SRL} and \textit{RL}.}
  \end{subfigure}

  \caption{Syntax of the two reversible flowchart languages.}
  \label{fig:rl_srl_grammar_and_structure}

\end{figure}
