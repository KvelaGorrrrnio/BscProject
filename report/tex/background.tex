\chapter*{Background}
\addcontentsline{toc}{chapter}{Background}%

% TODO: overordnet om flowcharts og reversible flowcharts
Flowcharts are a natural way to model imperative programs. Similarly, \textit{reversible} imperative programs can be naturally modeled by reversible flowcharts. The two models are similar --- however, to actually guarantee reversibility in reversible flowcharts, we may define some additional attributes. That is, we want to add an assertion to each edge such that any transfer of control is acknowledged. More specifically, the definition as seen in~\cite{REV} says that \\

\say{A \textit{reversible flowchart $F$} is a finite directed graph with three types of nodes, each of which represents an \textit{atomic operation}} \\

\noindent T. Yokotama et al.\ move on to describe the three atomic operations:\\
\begin{description}
  \item[(a)] the \textit{step} operation performs some injective (i.e.\ reversible) operation and passes the control flow to the outgoing edge,
  \item[(b)] the \textit{test} passes the control flow to one of two outgoing edges depending on a predicate $e$, and
  \item[(c)] the \textit{assertion} joins two edges and passes the control flow depending on a predicate $e$.
\end{description}~\\
\noindent The atomic operations can be seen in Figure~\ref{fig:atop}. Having these as elementary building blocks of our reversible flowcharts, it is trivial to invert a program; simply invert each edge and, naturally, any step operation in the flowchart. This, in turn, means that the inversion of a test becomes an assertion and vice versa. The inversion of each atomic operation can be seen in Figure~\ref{fig:atopinv}.

\begin{figure}[ht]
  \centering
  \begin{subfigure}[t]{0.3\textwidth}
    \centering
    \scalebox{0.8}{%
      \begin{tikzpicture}[auto, thick, node distance=2cm, >=triangle 45]
        \node (a) [stmt] {$a$};
        \node [output] (up)    [above of=a, node distance=1.1cm]{};
        \node [input]  (end)   [right of=a, node distance=1.5cm]{};
        \node [output] (start) [left  of=a, node distance=1.5cm]{};
        \node [output] (down)  [below of=a, node distance=1.1cm]{};

        \path[->] (start) edge node {} (a);
        \path[->] (a) edge node {} (end) ;

        \path[draw=none] (up) node {} (a);
        \path[draw=none] (down) node {} (a);
      \end{tikzpicture}
    }
    \caption{Step}
  \end{subfigure}
  \begin{subfigure}[t]{0.3\textwidth}
    \centering
    \scalebox{0.8}{%
      \begin{tikzpicture}[auto, thick, node distance=2cm, >=triangle 45]
        \node (a) [test] {$e$};
        \node [input]  (start) [left of=a, node distance=1.5cm]{};
        \node [output]  (up)   [above of=a, node distance=1.2cm]{};
        \node [output]  (ur)   [right of=up, node distance=1.2cm]{};
        \node [output] (down)  [below of=a, node distance=1.2cm]{};
        \node [output] (dr)    [right of=down, node distance=1.2cm]{};

        \path[->] (start) edge node {} (a);
        \path[-] (a) edge node {$t$} (up);
        \path[->] (up) edge node {} (ur);
        \path[-] (a) edge node {$f$} (down);
        \path[->] (down) edge node {} (dr);
      \end{tikzpicture}
    }
    \caption{Test}
  \end{subfigure}
  \begin{subfigure}[t]{0.3\textwidth}
    \centering
    \scalebox{0.8}{%
      \begin{tikzpicture}[auto, thick, node distance=2cm, >=triangle 45]
        \node [assert] (a)    {$e$};
        \node [input]  (up)   [below of=a, node distance=1.2cm]{};
        \node [input]  (dr)   [left of=up, node distance=1.2cm]{};
        \node [input]  (down) [above of=a, node distance=1.2cm]{};
        \node [input]  (ur)   [left of=down, node distance=1.2cm]{};
        \node [output] (end)  [right of=a, node distance=1.5cm]{};

        \path[-] (dr) edge node {} (up);
        \path[->] (up) edge node {$f$} (a);
        \path[-] (ur) edge node {} (down);
        \path[->] (down) edge node {$t$} (a);
        \path[->] (a) edge node {} (end);
      \end{tikzpicture}
    }
    \caption{Assertion}
  \end{subfigure}
  \caption{The three atomic operations of reversible flowcharts}\label{fig:atop}
\end{figure}

\begin{figure}[ht]
  \centering
  \begin{subfigure}[t]{0.3\textwidth}
    \centering
    \scalebox{0.8}{%
      \begin{tikzpicture}[auto, thick, node distance=2cm, >=triangle 45]
        \node (a) [stmt] {$a^{-1}$};
        \node [output] (up)    [above of=a, node distance=1.3cm]{};
        \node [input]  (end)   [right of=a, node distance=1.5cm]{};
        \node [output] (start) [left  of=a, node distance=1.5cm]{};
        \node [output] (down)  [below of=a, node distance=1.3cm]{};

        \path[->] (a) edge node {} (start);
        \path[->] (end) edge node {} (a) ;

        \path[draw=none] (up) node {} (a);
        \path[draw=none] (down) node {} (a);
      \end{tikzpicture}
    }
    \caption{Step}
  \end{subfigure}
  \begin{subfigure}[t]{0.3\textwidth}
    \centering
    \scalebox{0.8}{%
      \begin{tikzpicture}[auto, thick, node distance=2cm, >=triangle 45]
        \node [assert] (a)    {$e$};
        \node [input]  (up)   [below of=a, node distance=1.2cm]{};
        \node [input]  (dr)   [right of=up, node distance=1.2cm]{};
        \node [input]  (down) [above of=a, node distance=1.2cm]{};
        \node [input]  (ur)   [right of=down, node distance=1.2cm]{};
        \node [output] (end)  [left of=a, node distance=1.5cm]{};

        \path[-] (dr) edge node {} (up);
        \path[->] (up) edge node {$f$} (a);
        \path[-] (ur) edge node {} (down);
        \path[->] (down) edge node {$t$} (a);
        \path[->] (a) edge node {} (end);
      \end{tikzpicture}
    }
    \caption{Assertion}
  \end{subfigure}
  \begin{subfigure}[t]{0.3\textwidth}
    \centering
    \scalebox{0.8}{%
      \begin{tikzpicture}[auto, thick, node distance=2cm, >=triangle 45]
        \node (a) [test] {$e$};
        \node [input]  (start) [right of=a, node distance=1.5cm]{};
        \node [output]  (up)   [above of=a, node distance=1.2cm]{};
        \node [output]  (ur)   [left of=up, node distance=1.2cm]{};
        \node [output] (down)  [below of=a, node distance=1.2cm]{};
        \node [output] (dr)    [left of=down, node distance=1.2cm]{};

        \path[->] (start) edge node {} (a);
        \path[-] (a) edge node {$t$} (up);
        \path[->] (up) edge node {} (ur);
        \path[-] (a) edge node {$f$} (down);
        \path[->] (down) edge node {} (dr);
      \end{tikzpicture}
    }
    \caption{Test}
  \end{subfigure}
  \caption{Inversion of the three atomic operations of reversible flowcharts}\label{fig:atopinv}
\end{figure}

% figurer af de forskellige byggeklodser her tak

\noindent This is the general idea of reversible flowcharts, and two incarnations of this model are RL and SRL.\



% går så videre til det mere specifikke med RL og SRL
% og snakker om den formelle syntaks
\section*{RL and SRL}
\noindent Reversible Language and Structured Reversible Language --- RL and SRL for short, repectively --- are two reversible flowchart languages proposed in~\cite{REV}. RL is an assembly-like language with unstructured jumps, while SRL, as the name indicates, is a similar language but with control structures and no jumps. The two languages share a common subset of features --- namely their statements and expressions.

\subsection*{Grammar and Structure}

% figur der viser grammatikken her tak
\begin{figure}[ht]

  \begin{minipage}{\textwidth}
    \center
    $$\begin{matrix*}[l]
      \mathtt{p} & ::= & \mathtt{b} & \quad & \mathtt{b} & ::= & \mathtt{a}             & | & \texttt{ if }e\texttt{ then }b\texttt{ else }b\texttt{ fi }e\\
                 &     &           &        &            &  |  & \mathtt{b}\ \mathtt{b} & | & \texttt{ from }e\texttt{ do }b\texttt{ loop }b\texttt{ until }e\\
    \end{matrix*}$$
    (a) Structured reversible language \textit{SRL}.
  \end{minipage}

  \begin{minipage}{\textwidth}
    \center
    $$\begin{matrix*}[l]
      \mathtt{q} & ::= & \mathtt{d}^+                                      & & \mathtt{k} & ::= & \texttt{from }\mathtt{l} & & \mathtt{j} & ::= & \texttt{goto }\mathtt{l}\\
      \mathtt{d} & ::= & \mathtt{l}:\ \mathtt{k}\ \mathtt{a}^*\ \mathtt{j} &       &            &  |  & \texttt{fi }e\texttt{ from }\mathtt{l}\texttt{ else }\mathtt{l} &
        & & | & \texttt{if }e\texttt{ goto }\mathtt{l}\text{ else }\mathtt{l}\\
    \end{matrix*}$$
    (b) Unstructured reversible language \textit{RL}.
  \end{minipage}

  \begin{minipage}{\textwidth}
    \center
    $$\begin{matrix*}[l]
      \mathtt{a} & ::= & \mathtt{x}\oplus= e & \quad\quad\quad &  e & ::= & \mathtt{c} \ | \ \mathtt{x} \ | \ \mathtt{x}[ e] \ | \  e\otimes e \ | \ \texttt{top }\mathtt{x} \ | \ \texttt{empty }\mathtt{x}\\
                 &  |  & \mathtt{x}[ e]\oplus= e &     & \mathtt{c} & ::= & 0\ | \ 1\ |\ \cdots\ |\ 4294967295\\
                 &  |  & \texttt{push }\mathtt{x}\ \mathtt{x}      &     & \otimes    & ::= & \oplus \ | \ * \ | \ / \ | \ \cdots\\
                 &  |  & \texttt{pop  }\mathtt{x}\ \mathtt{x}      &     & \oplus     & ::= & +  \ | \  -  \ | \  \textasciicircum\\
                 &  |  & \texttt{skip}\\
    \end{matrix*}$$
    (c) Reversible step operations and expressions.
  \end{minipage}

  \begin{minipage}{\textwidth}
    \center
    $$\begin{matrix*}[l]
      \mathtt{SRL}:     & \mathtt{p}\in\mathtt{SRL}  & & \mathtt{b}\in\mathtt{Blk}\\
      \mathtt{RL}:      & \mathtt{q}\in\mathtt{RL}   & & \mathtt{d}\in\mathtt{RLBlk} & & \mathtt{j}\in\mathtt{Jump}  & & \mathtt{k}\in\mathtt{From} & & \mathtt{l}\in\mathtt{Label}\\
      \mathtt{SRL, RL}: & \mathtt{a}\in\mathtt{Step} & &  e\in\mathtt{Exp}   & & \mathtt{c}\in\mathtt{Const} & & \mathtt{x}\in\mathtt{Var}  & & \oplus,\otimes\in\mathtt{Op}\\
    \end{matrix*}$$
    (d) Syntax domains of \textit{SRL} and \textit{RL}.
  \end{minipage}

  \caption{Syntax of the two reversible flowchart languages.}
  \label{fig:rl_srl_grammar_and_structure}

\end{figure}

The grammar of the two languages along with the common structures are given in~\cite{REV} and can be seen in Figure~\ref{fig:rl_srl_grammar_and_structure}. As we see, while the two languages share expressions and step operations, RL consists of one or more (RL-)blocks, where each block is (uniquely) defined by a label and has a come-from assertion, zero or more step operations and an unstructured jump to any block in the program.

SRL is more linear; a program consists of exactly one (SRL-)block, where a block may either be an atomic step operation, a control structure --- that is, either an \texttt{if}- or a \texttt{do-until} structure --- or recursively a sequence of two blocks. Note that a block in RL is different from a block in SRL.\

%\subsection*{Inversion and translation}
