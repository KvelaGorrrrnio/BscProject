\chapter*{Implementation}
\addcontentsline{toc}{chapter}{Implementation}%

%This chapter describes the implementation of the full feature set of RL and SRL. Furthermore, the design of the web based user interface will be discussed.
We have, as was the goal of the project, successfully implemented interpreters for the reversible programming languages RL and SRL. Furthermore, both implementations support program inversion and -translation. Finally, a web based user interface for the two languages has been designed.






%% The interpreters
\section*{The Interpreters}
\addcontentsline{toc}{section}{The Interpreters}%

\subsection*{Changes}
\addcontentsline{toc}{subsection}{Changes}%

\subsection*{Common}
\addcontentsline{toc}{subsection}{Common}%

\subsection*{RL}
\addcontentsline{toc}{subsection}{RL}%

\subsection*{SRL}
\addcontentsline{toc}{subsection}{SRL}%






%% Program transformations
\section*{The Program Transformations}
\addcontentsline{toc}{section}{The Program Transformations}%

\subsection*{Inversion}
\addcontentsline{toc}{subsection}{Inversion}%

\subsubsection*{Common}
\addcontentsline{toc}{subsubsection}{Common}%

\subsubsection*{RL}
\addcontentsline{toc}{subsubsection}{RL}%

\subsubsection*{SRL}
\addcontentsline{toc}{subsubsection}{SRL}%

\subsection*{Translation}
\addcontentsline{toc}{subsection}{Translation}%

\subsubsection*{RL}
\addcontentsline{toc}{subsubsection}{RL}%

\subsubsection*{SRL}
\addcontentsline{toc}{subsubsection}{SRL}%




%% Web interface
\section*{The Web Interface}
\addcontentsline{toc}{section}{The Web Interface}%

The purpose of the web interface is to grant a simpler way to user for interacting with the interpreters.
This is split up in two parts:
The server, which handles the routing of the web server and serves the client interface, along with api-calls for the actual interaction with the Command-Line Interpreters;
The client part, which is the actual web interface that the user sees.
The implementation of these are described in the following subsections.

\subsection*{Server \& API}
\addcontentsline{toc}{subsection}{Server \& API}%

The web server is an independent node project, when builded uses the Client Web Interface and the Command-Line Interface as denpendencies.
These are build and copied into the web server project folder.
The executables for the Command-Line Interfaces are placed under \path{/web/server/bin} and the Web Client Interface is placed under \path{/web/server/client}.\\

\noindent
The server is written in ECMAScript 6, but since nodeJS (version 9 and below) does not support \texttt{import} statements natively, the Babel transpiler is used for running the ECMAScript 6 code as ECMAScript 5.
This is done in the entry-file \path{babel-server.js}, as a wrapper for the actual server configuration in \path{server.js}.
We run the transpiled code with node, and uses the Express package for opening ports, setting up the server and handling web-routes.
All communication between the API server and the client-side, is formatted as JSON; as is the results from the interpreters.
This way it is easy to parse data from the interpreter to the client interface via the API.

The server has Cross Origin Ressource Sharing (CORS) enabled, to allow for separation of the api server and the client web interface.
This allows for the server to be hosted at one address, while the interface is hosted at another.
CORS is enabled by setting the appropriate headers shown in Listing \ref{lst:cors_setup}.

\lstinputlisting[language=javascript,caption={CORS headers from /web/server/server.js.},label={lst:cors_setup},firstline=10,firstnumber=10,lastline=15]{../web/server/server.js}

The routing has two responsebilities: To handle API calls, which can be seen in Figure \ref{fig:full_api}; serve static files, when the client interface is requested. The defined routes are listed in Figure \ref{fig:server_routes}. Routes are divided into 3 categories: API routes, root requests and static files; where static files are the bundled css and javascript files, that the client interface requires.\\

\begin{figure}[H]
  \begin{tabular}{|l|p{8.7cm}|}\hline
    \textbf{Route} & \textbf{Responsebility}\\\hline
    \texttt{/}     & Fetch the builded client interface index page from (\path{/web/server/client/index.html}).\\\hline
    \texttt{/api*} & Here \texttt{*} is everything after \texttt{/api}, which is forwarded to the API router, whoms routes are described in Figure \ref{fig:full_api}. \\\hline
    \texttt{/:filename.:ext}     & Here \texttt{:filename.:ext} matches a static ressource, e.g. \texttt{bundle.js}. All static files are fetched from \path{/web/server/client}. Thus only files that the client interface uses can be requested.\\\hline
  \end{tabular}
  \caption{Routes for web server.}
  \label{fig:server_routes}
\end{figure}

If the client interface is hosted at a different address than the api, the \path{/web/server/client} folder can be removed, causing the route for the index page and the static pages to respond with a 404 (page not found) status and content.\\

\todo{API}\\

\begin{figure}[H]
  \begin{tabular}{|l|l|p{6.7cm}|}\hline
    \textbf{Route} & \textbf{Method} & \textbf{Responsebility}\\\hline
    \texttt{/run/:language} & \texttt{POST} & Here \texttt{:language} can either be \texttt{rl} or \texttt{srl}.
                                                This API-call executes the code that is posted along with the request, and returns the end-state of the program.
                                                The code submitted should be wrapped in a JSON object, with the attribute \texttt{code}.\\\hline
    \texttt{/run/log/:language} & \texttt{POST} & Is equivalent to \texttt{/run/:langauge}, but instead of returning the end-state
                                                    alone, it also returns the json-formattet execution-log.\\\hline
    \texttt{/invert/:language} & \texttt{POST} & Here \texttt{:language} can either be \texttt{rl} or \texttt{srl}.
                                                This API-call inverts the code.
                                                The code submitted should be wrapped in a JSON object, with the attribute \texttt{code}.\\\hline
    \texttt{/translate/:language} & \texttt{POST} & Here \texttt{:language} can either be \texttt{rl} or \texttt{srl}.
                                                This API-call translates the code from the specified language to its counterpart.
                                                The code submitted should be wrapped in a JSON object, with the attribute \texttt{code}.\\\hline
    \texttt{/template/list}  & \texttt{GET} & Returns a list of SRL and RL files, as a JSON-object. The object has the attributes \texttt{srl} and \texttt{rl}, where each corresponding value is a list of template-names for that language. \\\hline
    \texttt{/template/:file} & \texttt{GET} & Here \texttt{:file} is the template requested. 
                                              A JSON-object, with the attribute \texttt{code}, which contains the code of the requested template file, is returned.\\\hline
  \end{tabular}
  \caption{API routes.}
  \label{fig:full_api}
\end{figure}

\todo{Security (encodeURIComponent)}



\subsection*{Client}
\addcontentsline{toc}{subsection}{Client}%

\todo{Project important packages}\\
\todo{Project structure}\\
\todo{Features}\\




\section*{Further Improvements}
\addcontentsline{toc}{section}{Further Improvements}%
