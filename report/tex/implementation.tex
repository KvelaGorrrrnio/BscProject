\chapter*{Implementation}
\addcontentsline{toc}{chapter}{Implementation}%

%This chapter describes the implementation of the full feature set of RL and SRL. Furthermore, the design of the web based user interface will be discussed.
We have, as was the goal of the project, successfully implemented interpreters for the reversible programming languages RL and SRL. Furthermore, both implementations support program inversion and -translation. Finally, a web based user interface for the two languages has been designed.






%% The interpreters
\section*{The Interpreters}
\addcontentsline{toc}{section}{The Interpreters}%

\subsection*{Changes}
\addcontentsline{toc}{subsection}{Changes}%

\subsection*{Common}
\addcontentsline{toc}{subsection}{Common}%

\subsection*{RL}
\addcontentsline{toc}{subsection}{RL}%

\subsection*{SRL}
\addcontentsline{toc}{subsection}{SRL}%






%% Program transformations
\section*{The Program Transformations}
\addcontentsline{toc}{section}{The Program Transformations}%

\subsection*{Inversion}
\addcontentsline{toc}{subsection}{Inversion}%

\subsubsection*{Common}
\addcontentsline{toc}{subsubsection}{Common}%

\subsubsection*{RL}
\addcontentsline{toc}{subsubsection}{RL}%

\subsubsection*{SRL}
\addcontentsline{toc}{subsubsection}{SRL}%

\subsection*{Translation}
\addcontentsline{toc}{subsection}{Translation}%

\subsubsection*{RL}
\addcontentsline{toc}{subsubsection}{RL}%

\subsubsection*{SRL}
\addcontentsline{toc}{subsubsection}{SRL}%




%% Web interface
\section*{The Web Interface}
\addcontentsline{toc}{section}{The Web Interface}%

The purpose of the web interface is to grant a simpler way to users for interacting with the interpreters.
This is split up in two parts:
The server, which handles the routing of the web server and serves the client interface, along with api-calls for the actual interaction with the Command-Line Interpreters;
The client part, which is the actual web interface that the user sees.
The implementation of these are described in the following subsections.

\subsection*{Client Interface}
\addcontentsline{toc}{subsection}{Client Interface}%

\subsubsection{Features}
\addcontentsline{toc}{subsubsection}{Features}%

Before explaining the implementation of the client interface, the features of the interface will be described.
If we look at the User Interface seen in Figure \ref{fig:web_client_ui}, we have 3 rectangular areas: The toolbar at the top; the code editor, located below the toolbar on the left hand side; the result area, located below the toolbar on the right hand side.

\begin{figure}[H]
  \includegraphics[width=\textwidth]{web_client_ui.png}
  \caption{Screenshot of Web Client UI.}
  \label{fig:web_client_ui}
\end{figure}

\noindent
At the far left of the toolbar a radio button group with the options SRL and RL. The highlighted option indicates how the code in the code editor should be interpreted. If RL is chosen, the code is interpreted as if it were a RL program; likewise for SRL.\\
On the left hand side of the middle, the toolbar has some icons:\\

\begin{description}

  \item[\inlineicon{themes.png} Themes]~\\
    By hovering over the icon a dropdown menu, for choosing the colorscheme/ theme of the client interface, appears.\\
    \includegraphics[width=\textwidth]{web_client_themes.png}\\

  \item[\inlineicon{help.png} Help]~\\
    By clicking on this icon a modal window opens with help for the web interface, the modes and the languages.\\
    \includegraphics[width=\textwidth]{web_client_help.png}\\

  \item[\inlineicon{template.png} Templates]~\\
    By hovering over this icon a dropdown menu, where template programs for both RL and SRL can be loaded into the code editor, appears.\\
    \includegraphics[width=\textwidth]{web_client_templates.png}\\

  \item[\inlineicon{open.png} Open]~\\
    By click on this icon a modal window opens. Here it is possible to import and open previously stored programs.\\
    \includegraphics[width=\textwidth]{web_client_open.png}\\

  \item[\inlineicon{save.png} Save]~\\
    By clicking on this icon a modal window opens. Here it is possible to export, share and store the code currently loaded into the code editor.\\
    \includegraphics[width=\textwidth]{web_client_save.png}\\

\end{description}

The right hand side of the toolbar is dedicated to modes and their associated actions. There are 4 modes which are chosen from the radio button group at the far right:\\

\begin{description}

  \item[Run]~\\
    The Run mode utilises the run mode from the Command-Line Interface. The only action associated with the Run mode is \inlineicon{play} run, which executes the code written in the code editor, and displays the final program-state in the result area.

  \item[Step]~\\


  \item[Invert]~\\


  \item[Translate]~\\


\end{description}

\todo{Project important packages}\\
\todo{Project structure}\\
\todo{Features}\\

\subsection*{Server \& API}
\addcontentsline{toc}{subsection}{Server \& API}%

The web server is an independent node project, when builded uses the Client Web Interface and the Command-Line Interface as denpendencies.
These are build and copied into the web server project folder.
The executables for the Command-Line Interfaces are placed under \path{/web/server/bin} and the Web Client Interface is placed under \path{/web/server/client}.\\

\noindent
The server is written in ECMAScript 6, but since nodeJS (version 9 and below) does not support \texttt{import} statements natively, the Babel transpiler is used for running the ECMAScript 6 code as ECMAScript 5.
This is done in the entry-file \path{babel-server.js}, as a wrapper for the actual server configuration in \path{server.js}.
We run the transpiled code with node, and uses the Express package for opening ports, setting up the server and handling web-routes.
All communication between the API server and the client-side, is formatted as JSON; as is the results from the interpreters.
This way it is easy to parse data from the interpreter to the client interface via the API.

The server has Cross Origin Ressource Sharing (CORS) enabled, to allow for separation of the api server and the client web interface.
This allows for the server to be hosted at one address, while the interface is hosted at another.
CORS is enabled by setting the appropriate headers shown in Listing \ref{lst:cors_setup}.

\lstinputlisting[language=javascript,caption={CORS headers from /web/server/server.js.},label={lst:cors_setup},firstline=10,firstnumber=10,lastline=15]{../web/server/server.js}

The routing has two responsebilities: To handle API calls, which can be seen in Figure \ref{fig:full_api}; serve static files, when the client interface is requested. The defined routes are listed in Figure \ref{fig:server_routes}. Routes are divided into 3 categories: API routes, root requests and static files; where static files are the bundled css and javascript files, that the client interface requires.\\

\begin{figure}[H]
  \begin{tabular}{|l|p{8.7cm}|}\hline
    \textbf{Route} & \textbf{Responsebility}\\\hline
    \texttt{/}     & Fetch the builded client interface index page from (\path{/web/server/client/index.html}).\\\hline
    \texttt{/api*} & Here \texttt{*} is everything after \texttt{/api}, which is forwarded to the API router, whoms routes are described in Figure \ref{fig:full_api}. \\\hline
    \texttt{/:filename.:ext}     & Here \texttt{:filename.:ext} matches a static ressource, e.g. \texttt{bundle.js}. All static files are fetched from \path{/web/server/client}. Thus only files that the client interface uses can be requested.\\\hline
  \end{tabular}
  \caption{Routes for web server.}
  \label{fig:server_routes}
\end{figure}

If the client interface is hosted at a different address than the api, the \path{/web/server/client} folder can be removed, causing the route for the index page and the static pages to respond with a 404 (page not found) status and content.\\

\todo{API - features}\\

\begin{figure}[H]
  \begin{tabular}{|l|l|p{6.7cm}|}\hline
    \textbf{Route} & \textbf{Method} & \textbf{Responsebility}\\\hline
    \texttt{/run/:language} & \texttt{POST} & Here \texttt{:language} can either be \texttt{rl} or \texttt{srl}.
                                                This API-call executes the code that is posted along with the request, and returns the end-state of the program.
                                                The code submitted should be wrapped in a JSON object, with the attribute \texttt{code}.\\\hline
    \texttt{/run/log/:language} & \texttt{POST} & Is equivalent to \texttt{/run/:langauge}, but instead of returning the end-state
                                                    alone, it also returns the json-formattet execution-log.\\\hline
    \texttt{/invert/:language} & \texttt{POST} & Here \texttt{:language} can either be \texttt{rl} or \texttt{srl}.
                                                This API-call inverts the code.
                                                The code submitted should be wrapped in a JSON object, with the attribute \texttt{code}.\\\hline
    \texttt{/translate/:language} & \texttt{POST} & Here \texttt{:language} can either be \texttt{rl} or \texttt{srl}.
                                                This API-call translates the code from the specified language to its counterpart.
                                                The code submitted should be wrapped in a JSON object, with the attribute \texttt{code}.\\\hline
    \texttt{/template/list}  & \texttt{GET} & Returns a list of SRL and RL files, as a JSON-object. The object has the attributes \texttt{srl} and \texttt{rl}, where each corresponding value is a list of template-names for that language. \\\hline
    \texttt{/template/:file} & \texttt{GET} & Here \texttt{:file} is the template requested.
                                              A JSON-object, with the attribute \texttt{code}, which contains the code of the requested template file, is returned.\\\hline
  \end{tabular}
  \caption{API routes.}
  \label{fig:full_api}
\end{figure}

\todo{Security}
For accessing the Command-Line interface, listing and fetching template-files, the interface execFile(file, [arguments], callback) from the node module

% To secure the application, and the hosting system, most input parameters are validated before the the shell commands are executed; the input code is one of the paramaters which is not validated.
% To avoid command injections via code input, the execFile interface from nodes child\_process module, is used.
% execFile does not by default open a new shell, but spawns the specified command/ file directly, which minimizes the overhead.
% The

\begin{lstlisting}[language=javascript]
execFile(cmd,
        [mode, code, flags],
        {maxBuffer, timeout},
        (err, stdout, stderr) => {
  // ... callback content
});
\end{lstlisting}





\section*{Further Improvements}
\addcontentsline{toc}{section}{Further Improvements}%
