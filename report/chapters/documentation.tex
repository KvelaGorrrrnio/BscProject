\chapter*{Documentation}
\addcontentsline{toc}{chapter}{Documentation}%

\section*{Installation}
\addcontentsline{toc}{section}{Installation}%

Both the interpreters for RL and SRL and the web interface can be found at the same github repository: \href{https://github.com/KvelaGorrrrnio/BscProject}{KvelaGorrrrnio/BscProject}.\\
To get the code, clone the repository with:
\shcmd{$ git clone https://github.com/KvelaGorrrrnio/BscProject.git}

The different parts of the project uses different build systems. To simplify the build-flow Makefiles are used as a wrapping build-system, to supply a uniform build interface for the project.

\subsection*{Command-Line Interface}
\addcontentsline{toc}{subsection}{Command-Line Interface}%
The Interpreters and the Command-Line Interface are located under the \path{/src} directory, but can be build from the project root directory.
The underlying dependency manager and build system for the Command-Line Interface is Stack, which can be installed by one of following:\\
\shcmd{$ brew install haskell-stack cabal-install ghc # MacOS}\\
\shcmd{$ curl -sSL https://get.haskellstack.org/ | sh # Unix}\\
\shcmd{$ wget -qO- https://get.haskellstack.org/ | sh # Unix alternative}\\

\noindent
When standing at the project root, there are two ways of installing the Command-Line Interface.\\
First option is to \shcmd{$ make src}, which builds the \texttt{rl} and \texttt{srl} executables into \path{/src/bin}. Copy the executables to your local bin, for system wide usage.\\
Second option is to \shcmd{$ make install}, which installs the \texttt{rl} and \texttt{srl} executables directly to the stack local bin, for system wide usage. This requires that the stack local bin is in your \texttt{\$PATH}.

\subsection*{Web Interface}
\addcontentsline{toc}{subsection}{Web Interface}%

The web client interface is found under \path{/web/client} and the web server is found under \path{/web/server}.
Both the server and the client application is build and runned with NodeJS. NodeJS can be installed by one of the following:\\
\shcmd{$ brew install node               # MacOS}\\
\shcmd{$ sudo apt-get install nodejs npm # Ubuntu}\\
\shcmd{$ sudo pacman -S nodejs npm       # Arch}\\

\noindent
The default build command, soon to be described, combines the interpreters and the client web interface with the web server, such that the server has access to the interpreters and the client interface is accessible through the running server.\\
By running \shcmd{$ make web}, when standing at the project root, the web servers dependencies are installed, the Command-Line Interface and the web client interface is built and copied to the web server.
If builded successfully the last line should be \texttt{"Web server has been built."}.


\section*{Usage}
\addcontentsline{toc}{section}{Usage}%

\subsection*{Command-Line Interface}
\addcontentsline{toc}{subsection}{Command-Line Interface}%

 The Command-Line Interface for \texttt{rl} and \texttt{srl} are almost identitical, the only real difference is the naming (rl instead of srl, and vice versa).
 Thus only the interface for \texttt{rl} will be described.
 Both Command-Line Interfaces has \texttt{--help} flags, which displays the different modes, options and flags, of which can be chosen and set.\\

 \todo{Describe modes}\\

\subsection*{Web Interface}
\addcontentsline{toc}{subsection}{Web Interface}%

For starting the web server, use \shcmd{$ make server}. This should yield an output ending with
\begin{lstlisting}
  Server has started.
  Web interface is running at http://localhost:3001.
\end{lstlisting}

After starting the server and the above-shown output has been printed, every api-call and index page requests to the server is logged to \texttt{stdout}.
The log contains for each request timestamp and the requested path - along with information describing the outcome (erroneous or succesful).
For shutting down the server, use \texttt{Ctrl-C}.

\todo{Hosting on two different addresses. (webpack.prod.config.js)}

\section*{Testing}

When located at the root of the project, all tests, for both interpreters/cli and the web interface can be executed by \shcmd{$ make test}. For only getting output relevant for testing, build all targets with \shcmd{$ make} before running the tests.

\subsection*{Command-Line Interface}
\todo{CLI testing}\\

\subsection*{Web Interface}
\todo{Web client testing}\\
\todo{Web server testing}\\

