
%% The interpreters
\section{The Interpreters}

\subsection{Changes}\label{sec:changes}

It is important to note that we have made a few changes to the languages. We have modified some of the syntax described in Figure~\ref{fig:rl_srl_grammar_and_structure}, but also added some new step operations and core features. We have not, however, altered the very nature of any of the languages.\\

\noindent We found the paper\cite{REV} to be a bit unclear regarding types. The languages are described on the more hypothetical level, and the paper seems to assume some kind of type inference. We tried implementing a static check similar to type inference, but we deemed it too unrobust. This brings us to one of our most fundamental additions: explicit variable declarations. Each program must start with zero or more variable declarations with a specified type. For example, \texttt{list int a} declares variable \texttt{a} to be of type \texttt{list int}, etc. Using a variable in the program that has not been declared throws a runtime error.

Also, while the languages as described in the paper have lists limited to one dimension, our implementation of the core feature set supports indexing in an arbitrary number of dimensions. That is, you could declare a list variable as \texttt{list list int l} and index on this list with i.e. \texttt{l[2,5]} (assuming that the indices are not out of bounds). This, in particular, makes it a non-trivial task to implement robust type inference.\\

%Furthermore, in order to make the languages more user friendly we have tried to remove the concept of overflow. That is, instead of representing integers

\noindent We have added three new step operations to the languages: \texttt{swap}, \texttt{init}, and \texttt{free}. \texttt{swap} has already been described in \cite[p.~99]{REV}, however, it was not included in the formal grammar of the languages. It is a simple, but powerful, step operation that is imperative for the \textit{Fibonacci-pair function} shown as an unstructured flowchart on \cite[p.~99]{REV} and as a structured flowchart on \cite[p.~93]{REV}. \texttt{swap} works simply by swapping the two variable operands and is, thus, its own inverse. Trying to swap two variables of different types will throw a runtime error.

\texttt{init} was defined and implemented by us as a way to quickly obtain a list of zero-values in an arbitrary number of dimensions. That is, $\texttt{init} \ l \ [x,y,z]$ will initialise list $l$ to be a 3-dimensional table of lengths $x$, $y$, and $z$ consisting of zeroes. This is, in particular, useful in the translation from RL to SRL; Here, we must begin the resulting SRL program by initialising an $n \times n \times 3$ table, where $n$ is the number of blocks in the source RL program. This would, if we did not have \texttt{init} at our disposal, require three nested loops and three temporary variables which are never used again.

The inverse to \texttt{init} is \texttt{free}, which has a very similar syntax; $\texttt{free} \ l \ [x,y,z]$ will, if the dimensions and lengths of the list match $[x,y,z]$, reset list $l$ to an empty list. Do they not match, however, a runtime error will be thrown. This guarantees the reversibility of \texttt{init} and \texttt{free}. The inverse to \texttt{free} is, naturally, \texttt{init}.

We do not consider the addition of \texttt{init} and \texttt{free} to be \textit{too} radical; after all, the same functionality could be simulated by simply having a sufficiently long sequence of \texttt{push}- (if \texttt{init}) or \texttt{pop} (if \texttt{free}) operations.\\

\noindent We have also added two update operators: multiplication and division. Here we must be cautious: The right-hand side of a multiplication update must not be zero. This would lead to loss of information and make the program irreversible. Also, the right-hand side of a division update must be a divisor of the left-hand side --- a potential division rest would be lost, and the program would therefore not be reversible. If these rules are not respected, a runtime error is thrown. We have that $x \timeseq e$ is an inverse to $x \diveq e$ and vice versa. \\

\noindent Because expressions do not influence reversibility, one can add any arbitray operator to the languages. We found a few known operators to be a nice addition to the languages --- some of them are even mentioned in the paper, but not included in the formal grammar. We will keep this description brief:
\begin{description}
\item[Binary operators]~
  \begin{itemize}
  \item Power (infix, \texttt{**})
  \item Equality (infix, \texttt{=} and \texttt{!=})
  \item Relational (infix, \texttt{<}, \texttt{<=}, \texttt{>}, \texttt{>=})
  \item Modulo (infix, \texttt{\%})
  \item Logical conjunction (infix, \texttt{\&\&} or \texttt{and})
  \item Logical disjunction (infix, \texttt{||} or \texttt{or})
\end{itemize}
\item[Unary operators]~
\begin{itemize}
  \item Negation (prefix, \texttt{-} or \texttt{neg})
  \item Sign (prefix, \texttt{\~} or \texttt{sig})
  \item Logical negation (prefix, \texttt{!} or \texttt{not})
  \item Size of list (prefix, \texttt{\#} or \texttt{size})
  \item A predicate to determine if a variable contains only zero-values (prefix, \texttt{null})
\end{itemize}
\end{description}~

\noindent Finally, some of the RL-specific syntax has undergone some minor changes. The rather verbose syntax of the conditional come-from assertion has been changed from
\[\texttt{fi} \ e \ \texttt{from} \ l \ \texttt{else} \ l\]
\noindent to simply
\[\texttt{fi} \ e \ l \ l.\]
\noindent Similarly, the syntax of the conditional jump has been changed from
\[\texttt{if} \ e \ \texttt{goto} \ l \ \texttt{else} \ l\]
\noindent to simply
\[\texttt{if} \ e \ l \ l.\]

\subsection{The \textit{Common} Module}

% Values
% Types
% Expressions
% Step operations

% Errors
% Log

The \textit{Common} module contains the implementation of the subset of features that is shared between the two languages.

\subsubsection{Abstract syntax tree and utilities}
\texttt{Common/AST.hs} contains the parts of the specific abstract syntax trees that are shared between the two languages. Furthermore, it contains some extra data types and functions that are used in both the RL- and SRL modules.

At the most fundamental level are the identifiers, the values, and their types. Identifiers mark a variable in the program and can contain zero or more indices. No indices correspond, naturally, to just a variable $x$, while one or more indices correspond to indexing on a list $x[e,\dots]$. The implementation can be seen in~\ref{fig:identifier}.

Values in the languages are, as previously stated, either integers or lists. The implementation of \texttt{Value} can be seen in Figure~\ref{fig:val}. Note that list values have an extra field that specifies their type -- that is, essentially, the depth of the list; this makes it trivial to perform dynamic type checks in the interpreter. The implementation of \texttt{Type} as a recursive data type can be seen in~\ref{fig:type}.

\begin{figure}[H]
  \lstinputlisting[language=haskell, firstline=21, lastline=21]{../src/src/Common/AST.hs}
  \caption{Implementation of identifiers}\label{fig:identifier}
\end{figure}
\begin{figure}[H]
  \lstinputlisting[language=haskell, firstline=9, lastline=9]{../src/src/Common/AST.hs}
  \caption{Implementation of the fundamental value types}\label{fig:val}
\end{figure}
\begin{figure}[H]
  \lstinputlisting[language=haskell, firstline=174, lastline=174]{../src/src/Common/AST.hs}
  \caption{Implementation of the types}\label{fig:type}
\end{figure}

\noindent The store of our interpreters --- that is, the variable state --- is represented as a hashmap with strings as keys and \texttt{Value}s as values. Thus, reading a variable in an expression amounts to simply do a lookup in the store, while an update simply has to, well, update the store.\\

\noindent Next, we have expressions. These are exactly as described in the paper, but with the additions covered in \ref{sec:changes}. The implementation can be seen in Figure~\ref{fig:exp}. As expected, \texttt{Exp} is a recursive data type terminated by a literal value or a variable lookup. Since we do not support list literals, a literal value is assumed to be an integer.

\begin{figure}[h]
  \lstinputlisting[language=haskell, firstline=79, lastline=85]{../src/src/Common/AST.hs}
  \caption{Implementation of expressions}\label{fig:exp}
\end{figure}

\noindent Other than that, we have the \texttt{Binary} structure which takes a binary operator (\texttt{BinOp}) and two expressions, recursively, as arguments. Binary operators can easily be defined separately. The same goes for the \texttt{Unary} structure; this takes a unary operator (\texttt{UnOp}) and an expression, recursively. Unary operators, as binary operators, can easily be defined separately. The final expression is simply to mark parentheses; this makes it trivial to write a program to a file which, when parsed, has the guaranteed same expression precedences, and thus, same behaviour as the original.\\

\noindent Finally, we have step operations. Revisiting~\ref{fig:common}, we can focus on the definition of the step operations. We have that a step operation $a$ is given by
\[
\begin{matrix*}[l]
  {a} & ::= & {x}\mathrel{\oplus}= e \\
             &  |  & {x}[ e]\mathrel{\oplus}= e \\
             &  |  & \texttt{push }{x}\ {x} \\
             &  |  & \texttt{pop  }{x}\ {x} \\
             &  |  & \texttt{skip}
\end{matrix*}
\]
If we add our additional step operations and features (as described in~\ref{sec:changes}), we have
\[
\begin{matrix*}[l]
  {a} & ::= & {x}([ e,\dots])\mathrel{\oplus}= e \\
      &  |  & \texttt{push }{x}([e,\dots])\ {x}([e,\dots]) \\
      &  |  & \texttt{pop  }{x}([e,\dots])\ {x}([e,\dots]) \\
      &  |  & \texttt{skip} \\
%  \dots \\
      &  |  & \texttt{swap} \ x([e,\dots]) \ x([e,\dots]) \\
      &  |  & \texttt{init} \ x \ [e,\dots] \\
      &  |  & \texttt{free} \ x \ [e,\dots],
\end{matrix*}
\]
where $([e,\dots])$ means that you can optionally index in an arbitrary number of dimensions. The implementation of this was straightforward, and the corresponding code can be seen in Figure~\ref{fig:step}.

\begin{figure}[H]
  \lstinputlisting[language=haskell, firstline=46, lastline=53]{../src/src/Common/AST.hs}
  \caption{Implementation of the step operations}\label{fig:step}
\end{figure}

This module also contains the code for errors and the log, but we won't go into too much detail as to how they are implemented. The log is simply a list of specialised messages that can either be a step operation or an error.

\subsection{The \textit{RL} Module}



\subsection{The \textit{SRL} Module}
