% Translation
\section{Program Translation}
Translating a program from one of the two languages to the other is not quite as simple as inverting a program. However, after proving what it calls the Reversible Structured Program Theorem --- that is, the Structured Program Theorem for reversible languages --- the paper \cite{REV} presents a program translator for each of the languages, which, if followed closely, makes the task of translating the languages more doable.

\subsection{SRL to RL}

Generally speaking, translating a structured program in one language to an unstructured program in another language is pretty straightforward. When and where to jump depending on the control structure is very well defined. Dealing with a reversible language is not much diffierent.

\cite[Fig.~21]{REV} shows the exact translator from SRL to RL which is implemented in \texttt{Translation.hs} under the \textit{SRL} module (Appendix~\ref{app:SRL_Translation_hs}); To translate an SRL program, we start by creating the entry- and exit blocks of the resulting RL program with fresh labels. We then translate the main SRL block and put the result between these. We feed the entry- and exit labels as arguments to the translation of the main block along with two additional fresh labels which will each be assigned to an RL block later in the translation. The intuition in the block translator is that we always receive 4 labels; the first and last labels have been assigned to prevously generated blocks and indicate where we come from and where we are jumping to, respectively, but labels two and three have yet to be assigned. Translating an SRL block naturally depends on which type of block it is:
\begin{itemize}
  \item If we have a step operation, we simply generate two blocks from the two unassigned labels: one that contains the step operation and one that contains a skip. The first of these will be coming from the first assigned label and have an unconditional jump to the next. This next block will naturally be coming from the first RL block, but have a jump to the last assigned label.
  \item If we have a conditional SRL block we first generate two RL blocks corresponding to the branch (conditional jump) and the join point (conditional come-from assertion), and between these we individually translate both branches contained in the conditional SRL block. These are then connected to the generated start- and end blocks with the given labels and four fresh ones.
  \item If we have a loop, we do something very similar. The only difference is that the end block has a conditional jump that may jump back to the start block depending on the test from the SRL block.
  \item Finally, if we have a sequence, we translate both SRL blocks individually and chain them together with two fresh labels.
\end{itemize}
Looking at the implementation, one may notice that we use a monad transformer consisting of the writer monad and the state monad. We will elaborate: The state monad keeps track of a counter that is used to generate fresh labels, and the writer is simply used for pushing generated RL block onto a stack of RL blocks. Thus, the result of the writer monad is the translated program.




\subsection{RL to SRL}
% snak om opskriften fra artiklen
% vis, hvordan det er implementeret n√¶rmest 1:1
% dog med setup og alt muligt

Translating an unstructured program in one language to a structured program in another language is not \textit{that} straightforward. Deciding whether a certain pattern of conditional jumps is a loop or or an if-then-else body is not a trivial task. Reversible languages are no different; translating an RL program to a corresponding SRL program is a messy affair. However, the paper (\cite[p.~107]{REV}) presents a very neat translator for RL that is, in fact, quite intuitive: We simply keep track of an $(n+1) \times (n+1) \times 3$ table (where $n$ is the number of blocks in the original RL program) of boolean state values which indicates where we are, and where we came from, in our program. The extra row and column are `imaginary states which simulate where we come from when reaching the entry and where we go after reaching the exit. The number $3$ comes from simulating either (0) the come-from assertion (1) the step operations (2) the jump. We construct a resulting SRL program which consists of one single loop with one or more conditional blocks. Each of these will simply check (in the table of states) if we are in a certain RL block from the original program. If we are, we perform the operations contained in the original RL block and flip the states in the table corresponding the original unstructured jump.\\

\noindent When translating an RL program, we will first set up the state table, the entry assertion, the main loop, and the exit assertion of the resulting SRL program. The entry assertion is simply a sanity check which makes sure that the state table has no true entry at the beginning of the program. Likewise, the exit assertion makes sure that no entry in the state table is true at program exit. Furthermore, before entering the loop and after asserting the entry condition, we set the entry in the state table that corresponds to the entry block to true, and after the loop, before asserting the exit condition, we set the entry in the state table corresponding to the exit block to false. Finally, inside the loop, we will put the translation of the list of RL blocks. See Figure~\ref{fig:rltrlProg}.\\

\noindent Translating a list of blocks corresponds to translating the last block of the list with $E_{false}$ as argument, then using the result as argument when translating the second to last block in the list, etc. This can be achieved by simply folding the list from right to left using block translation as the operator and $E_{false}$ as starting value. $E_{false}$ is defined in the paper as an edge block (\texttt{if 0 then skip else skip fi 1}) that should halt the program if reached. See Figure~\ref{fig:rltrlBlks}.\\

\noindent The block translation takes, other than an RL block $l_i \, : \, k \ a^* \ j$, an SRL block $F$ as argument (as described when explaining the right fold). The translation works by first translating the jump with $i$ and $F$ as arguments. The result is then used as argument, alongside $i$, when translating the list af step operations $a^*$. \textit{This} result is then used as argument, once again alongside $i$, when translating the come-from assertion. This is similar to a small fold and it accumulates an SRL block for the resulting SRL program. See Figure~\ref{fig:rltrlBlk}.\\

\noindent When translating a come-from assertion, we receive an integer $i$ and an SRL block as arguments. If the come-from assertion is an entry, we simply generate a conditional SRL block which, if the first entry in the state table is true, will pass control the the step operations of the entry RL block. If it is not true, it will execute $F$. See Figure~\ref{fig:rltrlFromEntry}.

If we reach an unconditional come-from assertion $\texttt{from} \ l_j$ we generate a conditional SRL block which, if the entry in the state table corresponding to the RL block with label $l_j$ is true, we pass control to the RL block with label $l_i$, where $i$, as mentioned, is an argument passed to this translation function. If it is not true, it will execute $F$. See Figure~\ref{fig:rltrlFromFrom}.

Similarly, if we reach a conditional come-from assertion we will pass control flow depending on the expression inside. This particular case will result in a nested conditional block. See Figure~\ref{fig:rltrlFromFi}.\\

\noindent The translation of jumps is symmetric to the translation of come-from assertion, and thus, we will not go into too much detail here. The intuition is the same: If the corresponding state is true in the state table, we will pass control accordingly. If not, we move on the the next SRL block. The translation implementations of \texttt{exit}, \texttt{goto}, and \texttt{if} can be seen in Figures~\ref{fig:rltrlJumpExit},~\ref{fig:rltrlJumpGoto}, and~\ref{fig:rltrlJumpIf}, respectively.\\

\noindent Here, we use the reader monad to read the name of the state table --- it must be unique and thus, generated when translating the program --- and to read the association list which maps a label to an integer --- as used in the translation process.

\begin{figure}[H]
  \lstinputlisting[language=haskell, firstline=83, lastline=100]{../src/src/RL/Translation.hs}
  \caption{Translating an RL program.}\label{fig:rltrlProg}
\end{figure}

\begin{figure}[H]
  \lstinputlisting[language=haskell, firstline=102, lastline=104]{../src/src/RL/Translation.hs}
  \caption{Translating a list of blocks.}\label{fig:rltrlBlks}
\end{figure}

\begin{figure}[H]
  \lstinputlisting[language=haskell, firstline=106, lastline=109]{../src/src/RL/Translation.hs}
  \caption{Translating a single block.}\label{fig:rltrlBlk}
\end{figure}

\begin{figure}[H]
  \lstinputlisting[language=haskell, firstline=113, lastline=120]{../src/src/RL/Translation.hs}
  \caption{Translating a come-from assertion.}\label{fig:rltrlFromEntry}
\end{figure}

\begin{figure}[H]
  \lstinputlisting[language=haskell, firstline=113, lastline=120]{../src/src/RL/Translation.hs}
  \caption{Translating a come-from assertion (entry).}\label{fig:rltrlFromEntry}
\end{figure}

\begin{figure}[H]
  \lstinputlisting[language=haskell, firstline=122, lastline=131]{../src/src/RL/Translation.hs}
  \caption{Translating a come-from assertion (unconditional).}\label{fig:rltrlFromFrom}
\end{figure}

\begin{figure}[H]
  \lstinputlisting[language=haskell, firstline=133, lastline=153]{../src/src/RL/Translation.hs}
  \caption{Translating a come-from assertion (conditional).}\label{fig:rltrlFromFi}
\end{figure}

\begin{figure}[H]
  \lstinputlisting[language=haskell, firstline=172, lastline=183]{../src/src/RL/Translation.hs}
  \caption{Translating a jump (exit).}\label{fig:rltrlJumpExit}
\end{figure}

\begin{figure}[H]
  \lstinputlisting[language=haskell, firstline=185, lastline=194]{../src/src/RL/Translation.hs}
  \caption{Translating a jump (unconditional).}\label{fig:rltrlJumpGoto}
\end{figure}

\begin{figure}[H]
  \lstinputlisting[language=haskell, firstline=196, lastline=216]{../src/src/RL/Translation.hs}
  \caption{Translating a jump (conditional).}\label{fig:rltrlJumpIf}
\end{figure}

\subsection{Comments}
The translators described in the previous sections are very interesting, but not ideal in practice. When translating from SRL to RL, a \textit{lot} of blocks are produced. When translating from RL to SRL, a large loop of \textit{lots} of conditional blocks is produced. In fact, when translating back and forth multiple times, we will start to see an exponential growth on the number of lines of the resulting program. Figure~\ref{fig:linesfig} shows the actual growth in number of lines of two programs; \texttt{fib.srl}, which consists of $l_0=10$ lines, and \texttt{skip}, which consists of a $l_0=1$ line. As we see, after translating \texttt{fib.srl} and \texttt{skip.srl} six times the resulting programs will consist of more than $60,000$ and $20,000$ lines, respectively!

\pgfplotsset{compat = 1.3}
\begin{figure}[H]
\centering

  \begin{tikzpicture}

  \begin{axis} [
      xlabel=\#translations,
      ylabel=\#lines,
      ylabel shift=-2 pt,
      width=0.8\textwidth,
      legend style={at={(0.02,0.98)},anchor=north west},
      y tick label style={/pgf/number format/.cd,%
                scaled y ticks = false,
                set thousands separator={},
                fixed}
    ]


    \addplot table [
      x=t,
      y=l,
      col sep=comma,
    ] {tools/lines/fib.csv};
    \addlegendentry{fib.srl ($l_0 = 10$)}

    \addplot table [
      x=t,
      y=l,
      col sep=comma,
    ] {tools/lines/skip.csv};
    \addlegendentry{skip.srl ($l_0 = 1$)}

  \end{axis}

  \end{tikzpicture}

  \caption{Growth of a program for each translation.}\label{fig:linesfig}% ($10.1e^{1.45x}$)
\end{figure}
